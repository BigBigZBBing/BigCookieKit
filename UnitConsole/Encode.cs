using BenchmarkDotNet.Attributes;
using BigCookieKit.Communication;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace UnitConsole
{
    public class Encode
    {
        public const string temp = "这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。这就是垃圾回收器（后简称GC）起作用的地方。当我们的程序达到了一个特定的内存阀值，我们需要更多的堆空间的时候，GC开始起作用。GC将停止所有正在运行的线程，找出在堆中存在的所有不再被主程序访问的对象，并删除它们。然后GC会重新组织堆中所有剩下的对象来节省空间，并调整栈和堆中所有与这些对象相关的指针。你肯定会想到这个过程非常耗费性能，所以这时你就会知道为什么我们需要如此重视栈和堆里有些什么，特别是在需要编写高性能的代码时。";
        public const string message = temp + temp;

        //public const string message = "测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据测试失数据";

        [Benchmark(Description = "MemoryEncode")]
        public void MemoryEncode()
        {
            int offset = 0;
            byte[] stream = Encoding.UTF8.GetBytes(message);
            byte type = 0;
            byte[] len = null;
            if (stream.Length <= byte.MaxValue)
            {
                type = 0;
                len = new byte[1] { (byte)stream.Length };
            }
            else if (stream.Length <= short.MaxValue)
            {
                type = 1;
                len = BitConverter.GetBytes((short)stream.Length);
            }
            else if (stream.Length <= int.MaxValue)
            {
                type = 2;
                len = BitConverter.GetBytes(stream.Length);
            }
            Memory<byte> bytes = new byte[1 + len.Length + stream.Length];
            bytes.Span[0] = type;
            offset++;
            len.CopyTo(bytes.Span.Slice(offset, len.Length));
            offset += len.Length;
            stream.CopyTo(bytes.Span.Slice(offset, stream.Length));
        }

        static ReusableStream m_stream = new ReusableStream();

        [Benchmark(Description = "MemoryStreamEncode")]
        public void MemoryStreamEncode()
        {
            m_stream.Flush();
            byte[] stream = Encoding.UTF8.GetBytes(message);
            if (stream.Length <= byte.MaxValue)
            {
                m_stream.WriteByte(0);
                m_stream.Write(new byte[1] { (byte)stream.Length });
            }
            else if (stream.Length <= short.MaxValue)
            {
                m_stream.WriteByte(1);
                m_stream.Write(BitConverter.GetBytes((short)stream.Length));
            }
            else if (stream.Length <= int.MaxValue)
            {
                m_stream.WriteByte(2);
                m_stream.Write(BitConverter.GetBytes(stream.Length));
            }
            m_stream.Write(stream);
            m_stream.ToArray();
        }

        static List<byte> bytes = new List<byte>();
        [Benchmark(Description = "ListEncode")]
        public void ListEncode()
        {
            bytes.Clear();
            byte[] stream = Encoding.UTF8.GetBytes(message);
            if (stream.Length <= byte.MaxValue)
            {
                bytes.Add(0);
                bytes.Add((byte)stream.Length);
            }
            else if (stream.Length <= short.MaxValue)
            {
                bytes.Add(1);
                bytes.AddRange(BitConverter.GetBytes((short)stream.Length));
            }
            else if (stream.Length <= int.MaxValue)
            {
                bytes.Add(2);
                bytes.AddRange(BitConverter.GetBytes(stream.Length));
            }
            bytes.AddRange(stream);
            bytes.ToArray();
        }
    }
}
